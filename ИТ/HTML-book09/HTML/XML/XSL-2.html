<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<TITLE>Теория к лаб. работе N </TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1251">
<link REL="stylesheet" TYPE="text/css" HREF="mstyle.css">
</HEAD>
<BODY LEFTMARGIN=8 BGCOLOR="#FFFFFF" VLINK="#666666" LINK="#FF0000">
<h2><center>XML</center></h2>
<p>Рассмотрим простой пример XML-файла (ex01.xml).
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</xmp></td></tr></table><br>
Если мы откроем этот файл в браузере Internet Explorer, то мы увидим тот же самый текст, который приведен выше, вместе со всеми тегами и служебной информацией. Но нам не нужны теги и служебная информация! Мы хотим видеть только ту информацию, которая относится к делу, а при помощи тегов - управлять внешним видом этой информации. Эта задача решается легко и просто: необходимо к XML-файлу добавить шаблон преобразования - XSL-файл.
<p>Перепишем наш XML-файл в следующем виде (ex01-1.xml).
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='ex01-1.xsl'?>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</xmp></td></tr></table><br>
И создадим XSL-файл ex01-1.xsl. Текст файла приведен ниже.
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<p><strong><xsl:value-of select="//title"/></strong></p>
<p><xsl:value-of select="//author"/></p>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Если мы теперь откроем файл ex01-1.xsl в браузере Internet Explorer, то мы увидим, что наша задача решена, - на экране осталась только необходимая нам информация, все теги исчезли. Результат, который вы получите на экране браузера, приведен ниже.
<br><br>
<b>"Заметки об XSL"</b>
<br>Леонов Игорь Васильевич<br><br>
<p>Легко также увидеть, что порядок вывода строк у нас определяется только содержанием шаблона преобразования - XSL-файла. При необходимости шаблон можно легко поменять, абсолютно не меняя наш основной XML-файл.
<p>Перепишем XML-файл. Информационную часть изменять не будем, а шаблон укажем другой ex01-2.xml.
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='ex01-2.xsl'?>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</xmp></td></tr></table><br>
Создадим XSL-файл ex01-2.xsl. Текст файла приведен ниже.
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<p><strong><xsl:value-of select="//author"/></strong></p>
<p><xsl:value-of select="//title"/></p>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Если мы теперь откроем файл ex01-2.xsl в браузере Internet Explorer, то результат будет другим.
<br><br>
Леонов Игорь Васильевич
<br><br><b>"Заметки об XSL"</b>
<p>Отметим теперь момент, который является ключевым для разработчиков баз данных. Информация в XML-странице появляется, как правило, в результате запроса к базе данных. Запрос к базе данных в многопользовательской среде - это весьма дорогостоящая операция. Предположим теперь, что у нас нет XML и мы формируем стандартные статические HTML-страницы. В этом случае для решения задачи простого преобразования внешнего представления информации, например, для изменения сортировки, у нас есть два способа решения проблемы: выполнить запрос и сохранить результаты в каком-либо временном буфере на сервере или каждый раз при изменении внешнего представления выполнять новый запрос и формировать HTML-страницу заново.
<p>Первый способ требует трудоемкого программирования, второй способ значительно увеличивает нагрузку на сервер базы данных, производительность которого часто является узким местом системы, - пользователю всегда хочется получать результаты быстрее.
<p>XML и XSL - это исчерпывающее решение описанной выше проблемы. Фактически XML-страница - это и есть временный буфер для результатов запросов. Только вместо нестандартного и трудоемкого программирования мы теперь используем стандартный механизм XSL.
<p>Есть и еще одно соображение, которое может быть существенным для разработчиков баз данных. Большинство современных СУБД могут форматировать результаты запроса к базе данных в виде XML-файла. То есть при построении интерфейса пользователя в рамках технологии XML и XSL мы добиваемся определенной независимости от поставщика СУБД. В части организации вывода - практически полной независимости. А эта часть весьма велика в большинстве прикладных систем, ориентированных на работу с базами данных. Конечно, помимо вывода есть еще ввод и серверная обработка бизнес-логики, но здесь вам придется искать какие-то иные решения.
<h3>Первые шаги</h3> 
<p>Разберем теперь более подробно первый пример. Напомним его текст.
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</xmp></td></tr></table><br>
Первая строка информирует браузер о том, что файл имеет формат XML. Атрибут <i>version</i> является обязательным. Атрибут <i>encoding</i> не является обязательным, но если у вас в тексте есть русские буквы, то необходимо вставить этот атрибут, в противном случае XML-файл просто не будет обрабатываться, - вы получите сообщение об ошибке.
<p>Следующие строки - это тело XML-файла. Оно состоит из элементов, которые в совокупности образуют древовидную структуру. Элементы идентифицируются тегами и могут быть вложены друг в друга.
<p>Элементы могут иметь атрибуты, значения которых тоже могут обрабатываться в соответствии с шаблоном.
<p>На верхнем уровне XML-файла всегда находится один элемент. То есть файл вида
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
<tutorial>
<title>"Введение в CSP"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</xmp></td></tr></table><br>
не будет обрабатываться браузером. Для преобразования в корректный XML-файл нужно добавить теги элемента верхнего уровня, например
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<knowledgeDatabase>
<tutorial>
<title>"Заметки об XSL"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
<tutorial>
<title>"Введение в CSP"</title>
<author>Леонов Игорь Васильевич</author>
</tutorial>
</knowledgeDatabase>
</xmp></td></tr></table><br>
Отметим, что имена тегов чувствительны к регистру символов. Подробнее об этом можно прочесть в любой книге по XML - элементам и атрибутам в этих книгах уделяется достаточно большое внимание.
<p>Перейдем теперь к шаблону преобразования - к XSL-файлу. Задача XSL-файла - преобразовать дерево XML-файла в другое дерево, которое, например, будет соответствовать формату HTML и может быть изображено на экране браузера с учетом форматирования, выбора шрифтов и т.п.
<p>Для того, чтобы браузер выполнил необходимое преобразование, нужно в XML-файле указать ссылку на XSL-файл
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='ex01-1.xsl'?>
</xmp></td></tr></table><br>
Рассмотрим теперь текст XSL-файла
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<p><strong><xsl:value-of select="//title""/></strong></p>
<p><xsl:value-of select="//author"/></p>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Первая строка файла содержит тег элемента <i>xsl:stylesheet</i>. Атрибуты элемента - номер версии и ссылка на пространство имен. Эти атрибуты элемента <i>xsl:stylesheet</i> являются обязательными. В нашем случае пространство имен - это все имена элементов и их атрибутов, которые могут использоваться в XSL-файле. Для XSL-файлов ссылка на пространство имен является стандартной.
<p>Заметим, что XSL-файл является одной из разновидностей XML-файлов. Он не содержит пользовательских данных, но формат его тот же самый. Файл содержит элемент верхнего уровня <i>xsl:stylesheet</i>, а далее идет дерево правил преобразования.
<p>В настоящем документе мы не будем подробно пояснять, что означает каждый элемент XSL-файла. Мы будем приводить различные примеры и показывать результат в каждом примере. Читатель сможет самостоятельно сопоставить различные элементы XSL-файла и инициируемые этими элементами преобразования исходного XML-файла с пользовательской информацией.
<p>В первом примере мы посмотрели, как с помощью элемента <i>xsl:value-of</i> можно вывести в HTML-формате содержание элемента (текст, заключенный между тегами). Теперь мы посмотрим, как при помощи того же самого элемента можно вывести значение атрибута элемента.
<p>Рассмотрим следующий XML-файл ex02-1.xml
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='ex02-1.xsl'?>
<tutorial>
<dog caption="Собака: " name="Шарик">
<dogInfo weight="18 кг" color="рыжий с черными подпалинами"/>
</dog>
</tutorial>
</xmp></td></tr></table><br>
В этом файле информация хранится не в содержании элементов, а в виде значений атрибутов. Файл ex02-1.xsl имеет вид
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<P><B><xsl:value-of select="//dog/@caption"/></B>
<xsl:value-of select="//dog/@name"/>.
<xsl:value-of select="//dogInfo/@weight"/>, <xsl:value-of select="//dogInfo/@color"/>.</P>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Обратите внимание на синтаксис ссылки на атрибут элемента - //dog/@name. Имя элемента и имя атрибута разделены парой символов "/@". В остальном синтаксис тот же самый, что и для ссылки на содержание элемента.
<p>Результат имеет следующий вид:
<p>Собака: Шарик. 18 кг, рыжий с черными подпалинами.
<p>Обратим теперь внимание на следующий момент. В XSL-файле мы никак не использовали элемент <i>tutorial</i>. На самом деле можно было использовать полный путь. Перепишем наш XML-файл, увеличив глубину дерева (ex02-2.xml)
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<?xml-stylesheet type='text/xsl' href='ex02-2.xsl'?>
<tutorial>
<animals>
<dog caption="Собака: " name="Шарик">
<dogInfo weight="18 кг" color="рыжий с черными подпалинами"/>
</dog>
</animals>
</tutorial>
</xmp></td></tr></table><br>
Файл ex02-2.xsl имеет вид
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<P><B><xsl:value-of select="//animals/dog/@caption"/></B>
<xsl:value-of select="//animals/dog/@name"/>.
<xsl:value-of select="//animals/dog/dogInfo/@weight"/>, <xsl:value-of select="//dogInfo/@color"/>.</P>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Результат будет тем же самым.
<p>Собака: Шарик. 18 кг, рыжий с черными подпалинами.
<p>В этом примере мы использовали полную ссылку для значений атрибутов. При выводе одиночных значений оба варианта - полная и сокращенная ссылка - работают одинаково.
<p>На этом мы закончим разбор примеров с выводом одиночных значений и перейдем к выводу табличной информации - к выводу результатов запроса.
<h3>Вывод результатов запроса</h3>
<p>До тех пор, пока мы работаем с несколькими реквизитами одного и того же объекта, разницы между XML и HTML практически нет. Однако стоит нам перейти к информации, содержащей несколько строк, как выгоды XML становятся очевидны. Но прежде чем перейти к выгодам, научимся выводить на экран простую таблицу.
<p>Рассмотрим следующий XML-файл - ex03.xml. Текст его приведен ниже.
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251"?>
<tutorial>
<animals>
  <dogs>
  <dog>
    <dogName>Шарик</dogName>
    <dogWeight caption="кг">18</dogWeight>
    <dogColor>рыжий с черными подпалинами</dogColor>
  </dog>
  <dog>
    <dogName>Тузик</dogName>
    <dogWeight caption="кг">10</dogWeight>
    <dogColor>белый с черными пятнами</dogColor>
  </dog>
  <dog>
    <dogName>Бобик</dogName>
    <dogWeight caption="кг">2</dogWeight>
    <dogColor>бело-серый</dogColor>
  </dog>
  <dog>
    <dogName>Трезор</dogName>
    <dogWeight caption="кг">25</dogWeight>
    <dogColor>черный</dogColor>
  </dog>
  </dogs>
</animals>
</tutorial>
</xmp></td></tr></table><br>
Предположим, что это результат запроса к базе данных и выведем на экран соответствующую таблицу.
<h3>Простая таблица</h3>
<p>Первый шаг - это, как всегда, добавление шаблона преобразования. Модифицируем наш файл, добавив в него ссылку на шаблон. В результате получим файл ex03-1.xml.
<p>В этот файл добавлен шаблон преобразования ex03-1.xsl.
<p>Рассмотрим этот шаблон подробнее. Вот его текст.
<table><tr><td bgcolor=aqua><xmp>
<?xml version="1.0" encoding="WINDOWS-1251" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/TR/WD-xsl">
<xsl:template match="/">
<table border="1">
<tr bgcolor="#CCCCCC">
<td align="center"><strong>Кличка</strong></td>
<td align="center"><strong>Вес</strong></td>
<td align="center"><strong>Цвет</strong></td>
</tr>
<xsl:for-each select="tutorial/animals/dogs/dog">
<tr bgcolor="#F5F5F5">
<td><xsl:value-of select="dogName"/></td>
<td align="right"><xsl:value-of select="dogWeight"/> <xsl:value-of select="dogWeight/@caption"/></td>
<td><xsl:value-of select="dogColor"/></td>
</tr>
</xsl:for-each>
</table><br>
</xsl:template>
</xsl:stylesheet>
</xmp></td></tr></table><br>
Первая строка - новая для вас в XSL-файле (но не в XML-файлах!). Она говорит о том, что в XSL-файле нужно нормально воспринимать русские буквы. Без этой строки браузер не сможет корректно обработать русский текст в XSL-файле. Следующие две строки шаблона являются уже привычными. Следующие шесть строк - это строка, содержащая заголовки столбцов таблицы. Конструкция для извлечения текста заголовков таблицы вам уже знакома. А вот десятая строка тоже является новой:
<table><tr><td bgcolor=aqua><xmp>
<xsl:for-each select="tutorial/animals/dogs/dog">
</xmp></td></tr></table><br>
Этот элемент шаблона позволяет выбрать и просмотреть все группы информации, полный путь к которым задается списком тегов <i>"tutorial/animals/dogs/dog"</i>. Обратите внимание - путь задается полностью, ни один из тегов опустить нельзя. Далее в ячейки таблицы помещается информация о наших собаках. В отличие от первых примеров путь к соответствующей информации тоже задается полностью. Попробуем, например, разместить информацию о кличке чуть-чуть иначе ex03-2.xml:
<table><tr><td bgcolor=aqua><xmp>
<dogName>
<dogNick>Шарик</dogNick>
</dogName>
</xmp></td></tr></table><br>
Если мы в соответствующем XSL-файле поставим ссылку <i>&LT;xsl:value-of select="dogNick"/&GT;</i>, то в соответствующем столбце никакой клички мы не увидим. Ссылка должна быть полной - <i>&LT;xsl:value-of select="dogName/dogNick"/&GT;</i>. Вы можете самостоятельно поэкспериментировать с файлом ex03-2.xsl. Правильный результат приведен ниже.
<table border="1">

  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>

    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
  <tr bgcolor="#F5F5F5">

    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
<h3>Сортировка</h3>
В предыдущих примерах порядок строк в таблице полностью соответствовал группам тегов в XML-файле. Этот порядок можно изменять. Добавим в тег
<table><tr><td bgcolor=aqua><xmp>
<xsl:for-each select="tutorial/animals/dogs/dog">
</xmp></td></tr></table><br>
атрибут <i>order-by</i>
<table><tr><td bgcolor=aqua><xmp>
<xsl:for-each select="tutorial/animals/dogs/dog" order-by="dogName">
</xmp></td></tr></table><br>
Наша таблица примет вид (ex03-3.xml, ex03-3.xsl).
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">

    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>

    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
</table><br>
Более интересные результаты мы получим, если попытаемся отсортировать таблицу по столбцу "Вес". Вначале попробуем сделать по аналогии с предыдущим примером - атрибут <i>order-by="dogName"</i> заменим на <i>order-by="dogWeight"</i>. Результат приведен ниже  (ex03-4.xml, ex03-4.xsl).
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>

    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
Таблица действительно отсортирована по столбцу "вес", но это не числовая, а строковая сортировка! Для того, чтобы браузер воспринял значения как числа, ему необходимо об этом сказать, - вместо <i>order-by="dogWeight"</i> необходимо написать <i>order-by="number(dogWeight)"</i>. Теперь мы получили правильный результат (ex03-5.xml, ex03-5.xsl).
<table border="1">

  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>

    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">

    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
Приведем теперь пример сортировки по нескольким столбцам. Различные элементы в атрибуте <i>order-by</i> должны разделяться символом ";" -   <i>order-by="number(dogWeight); dogName" (ex03-6.xml, ex03-6.xsl)</i>. Таблица приведена ниже.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">10 кг</td>
    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>

    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">18 кг</td>
    <td>бело-серый</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
</table><br>
Следующий пример работает только под управлением XML-парсера версии 3. В нем строки сортируются по одному столбцу - по кличке собаки. Этот пример уже приводился выше, однако теперь мы используем новый синтаксис (ex03-7.xml, ex03-7.xsl).
<p>Отметим разницу.
<p>При использовании нового синтаксиса используется ссылка на другое пространство имен
<table><tr><td bgcolor=aqua><xmp>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
</xmp></td></tr></table><br>
Это очень важный момент, и его никогда нельзя упускать из виду.
<p>Кроме того, мы убрали атрибут <i>order-by</i> в элементе <i>xsl:for-each</i> и добавили другой элемент
<table><tr><td bgcolor=aqua><xmp>
<xsl:sort order="ascending" select="dogName"/>
</xmp></td></tr></table><br>
Если элемент <i>xsl:sort</i> присутствует в элементе <i>xsl:for-each</i>, то он всегда должен стоять сразу после элемента <i>xsl:for-each</i>. Синтаксис элемента <i>xsl:sort</i> достаточно очевиден. В нем используются два атрибута: атрибут <i>order</i> - способ сортировки (по возрастанию или по убыванию) и атрибут <i>select</i> - имя поля, по которому производится сортировка. Если нам нужно отсортировать по первому элементу, как в данном примере, то вместо <i>"dogName"</i> можно было поставить точку - ".", для других элементов нужно указывать его имя, например <i>"dogColor"</i>, если нам нужно отсортировать записи по цвету собаки. На самом деле атрибутов может быть пять - <i>select, lang, data-type, order</i> и <i>case-order</i>, но мы не будем здесь рассматривать все эти атрибуты, поскольку здесь мы не преследуем цель дать полное описание всех элементов, используемых в XSL, и их атрибутов.
<p>Таблица результатов приведена ниже.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>

    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
</table><br>
С использованием нового синтаксиса легко сменить сортировку по возрастанию на сортировку по убыванию (ex03-8.xml, ex03-8.xsl). Этот пример работает только под управлением XML-парсера версии 3.
<p>Разница заключается в одной строке
<table><tr><td bgcolor=aqua><xmp>
<xsl:sort order="descending" select="dogName"/>
</xmp></td></tr></table><br>
Мы изменили значение атрибут <i>order</i> - значение <i>ascending</i> заменено на <i>descending</i>.
<p>Таблица результатов приведена ниже.
<table border="1">
  <tr bgcolor="#CCCCCC">

    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>

    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>

    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
</table><br>
Покажем теперь сортировку по нескольким полям (ex03-9.xml, ex03-9.xsl). Этот пример работает только под управлением XML-парсера версии 3.
<p>В этом примере у нас фигурируют две строки с элементом <i>xsl:sort</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:sort order="ascending" select="number(dogWeight)" data-type="number"/>
<xsl:sort order="ascending" select="dogName"/>
</xmp></td></tr></table><br>
Строки вначале сортируются по весу собаки, а затем по их кличкам в алфавитном порядке. Обратите внимание - для того, чтобы сортировка выполнялась в числовой последовательности, в элемент <i>xsl:sort</i> мы добавили атрибут <i>data-type</i>. Таблица результатов приведена ниже.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>

    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Волчонок</td>
    <td align="right">3 кг</td>
    <td>темно-серый</td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">10 кг</td>
    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>

    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">18 кг</td>
    <td>бело-серый</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
</table><br>
Заменив значение атрибута <i>order-by</i> на <i>descending</i>, мы легко сгруппируем записи о собаках с одинаковым весом так, что клички будут идти в обратном алфавитном порядке. Соответствующий пример вы легко построите сами.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>

    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Волчонок</td>
    <td align="right">3 кг</td>
    <td>темно-серый</td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>

    <td align="right">10 кг</td>
    <td>черный</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">18 кг</td>
    <td>бело-серый</td>
  </tr>
</table><br>
<h3>Элемент XSL:IF - фильтр</h3>
<p>Рассмотрим теперь способы фильтрации строк таблицы. Первый пример использует старый синтаксис. В нем условие фильтрации указывается непосредственно в атрибуте <i>select</i> (ex04-1.xml, ex04-1.xsl).
<p>Ниже приведена строка, в которую мы внесли необходимые изменения.
<table><tr><td bgcolor=aqua><xmp>
<xsl:for-each select="tutorial/animals/dogs/dog[dogWeight$gt$10] " order-by="number(dogWeight); dogName;">
</xmp></td></tr></table><br>
И таблица результатов.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>

    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
Вы видите, что в таблице остались только те собаки, чей вес превышает 10 кг, причем первым стоит Шарик, чей вес меньше.
<p>Все дальнейшие примеры работают только под управлением XML-парсера версии 3.
<p>Более гибкие возможности нам предоставляет новый синтаксис (ex04-2.xml, ex04-2.xsl). Обратите внимание - в новом синтаксисе атрибут <i>order-by</i> в элементе <i>xsl:for-each</i> не поддерживается, вместо него мы вставили два элемента <i>xsl:sort</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:sort order="ascending" select="number(dogWeight)"/>
<xsl:sort order="ascending" select="dogName"/>
</xmp></td></tr></table><br>
Кроме того, условие фильтра у нас вынесено в отдельный элемент <i>xsl:if</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="dogWeight&gt;10">
</xmp></td></tr></table><br>
Не забывайте указывать конечный тег элемента <i>xsl:if</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="dogWeight&gt;10">
<tr bgcolor="#F5F5F5">
<td><xsl:value-of select="dogName"/></td>
<td align="right"><xsl:value-of select="dogWeight"/> <xsl:value-of select="dogWeight/@caption"/></td>
<td><xsl:value-of select="dogColor"/></td>
</tr>
</xsl:if>
</xmp></td></tr></table><br>
В этом примере таблица результатов полностью аналогична предыдущей.
<table border="1">
  <tr bgcolor="#CCCCCC">

    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>

    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>

</table><br>
Полностью преимущества нового синтаксиса проявляются при использовании функций. 
<p>Рассмотрим следующий пример (ex04-3.xml, ex04-3.xsl). В этом примере используется функция <i>position()</i>, определяющая порядковый номер фрагмента в исходном XML-файле.
<p>Соответствующий элемент <i>xsl:if</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="position()<3">
</xmp></td></tr></table><br>
Результат.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>

    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>
  </tr>
</table><br>
Продемонстрируем теперь использование более интересных функций - <i>start-with(string,startSubstring)</i> и <i>contains(string,anySubstring)</i>. Функция <i>start-with(string,startSubstring)</i> проверяет, начинается ли строка <i>string</i> с подстроки  <i>startSubstring></i>. Пример - ex04-4.xml, ex04-4.xsl).
<p>Синтаксис элемента <i>xsl:if</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="starts-with($varDogName,$varStartWith)">
</xmp></td></tr></table><br>
В этом элементе мы использовали переменные. Значения переменных были инициализированы ранее
<table><tr><td bgcolor=aqua><xmp>
<xsl:variable name="varStartWith">Т</xsl:variable>
<xsl:for-each select="tutorial/animals/dogs/dog">
<xsl:variable name="varDogName"><xsl:value-of select="dogName"/></xsl:variable>
</xmp></td></tr></table><br>
Переменная <i>varStartWith</i> представляет собой подстроку, с которой должны начинаться требуемые нам клички. Она не меняется, поэтому инициализируется перед циклом. Переменная <i>varDogName</i> содержит кличку собаки, она меняется на каждом шаге цикла и, соответственно, инициализируется в теле цикла.
<p>Результат.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>

    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Тузик</td>
    <td align="right">10 кг</td>
    <td>белый с черными пятнами</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
Функция <i>contains(string,anySubstring)</i> проверяет, содержит ли строка <i>string</i> подстроку  <i>anySubstring</i>. Пример - ex04-5.xml, ex04-5.xsl.
<p>Синтаксис элемента <i>xsl:if</i>.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="contains($varDogName,$varStartWith)">
</xmp></td></tr></table><br>
Этот пример полностью аналогичен предыдущему.
<p>Результат.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>

    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>

  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
Два элемента <i>xsl:if</i>, вложенные друг в друга, дают нам эффект оператора <i>AND</i> (ex04-6.xml, ex04-6.xsl).
<p>Соответствующий фрагмент XSL-файла.
<table><tr><td bgcolor=aqua><xmp>
<xsl:if test="dogWeight&gt;10">
<xsl:if test="dogWeight&lt;20">
...
</xsl:if>
</xsl:if>
</xmp></td></tr></table><br>
Результат.
<table border="1">
  <tr bgcolor="#CCCCCC">

    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>
    <td align="right">18 кг</td>

    <td>рыжий с черными подпалинами</td>
  </tr>
</table><br>
Можно добиться и эффекта оператора OR. Для этого нам нужно включить два цикла, в каждом из которых формируется своя выборка   (ex04-7.xml, ex04-7.xsl).
<p>Соответствующий фрагмент XSL-файла.
<table><tr><td bgcolor=aqua><xmp>
<xsl:for-each select="tutorial/animals/dogs/dog">
<xsl:sort order="ascending" select="number(dogWeight)"/>
<xsl:if test="dogWeight&lt;10">
<tr bgcolor="#F5F5F5">
<td><xsl:value-of select="dogName"/></td>
<td align="right"><xsl:value-of select="dogWeight"/> <xsl:value-of select="dogWeight/@caption"/></td>
<td><xsl:value-of select="dogColor"/></td>
</tr>
</xsl:if>
</xsl:for-each>
<xsl:for-each select="tutorial/animals/dogs/dog">
<xsl:sort order="ascending" select="number(dogWeight)"/>
<xsl:if test="dogWeight&gt;15">
<tr bgcolor="#F5F5F5">
<td><xsl:value-of select="dogName"/></td>
<td align="right"><xsl:value-of select="dogWeight"/> <xsl:value-of select="dogWeight/@caption"/></td>
<td><xsl:value-of select="dogColor"/></td>
</tr>
</xsl:if>
</xsl:for-each>
</xmp></td></tr></table><br>
Результат.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>

  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Шарик</td>

    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>

  </tr>
</table><br>
Если сортировка не требуется, то можно вставить два элемента <i>xsl:if</i> в один элемент <i>xsl:for-each</i>.
<h3>Элемент XSL:IF - улучшение внешнего вида таблиц</h3>
<p>Элемент <i>xsl:if</i> можно применять не только для фильтрации строк выборки. Очевидно, что он может быть полезен и во многих других областях. В этом параграфе мы разберем пример использования элемента <i>xsl:if</i> для улучшения внешнего вида таблицы. Заодно мы продемонстрируем реальное использование функции <i>position()</i>. Мы будем использовать эту функцию для того, чтобы чередовать цвет четных и нечетных строк таблицы  (ex04-8.xml, ex04-8.xsl). 
<p>Фрагмент XSL-файла, который отвечает за требуемое чередование.
<table><tr><td bgcolor=aqua><xmp>
<tr>
<xsl:if test="position() mod 2 = 0">
<xsl:attribute name="bgcolor">#CCCCCC</xsl:attribute>
</xsl:if>
</xmp></td></tr></table><br>
С элементом <i>xsl:if</i> и с функцией <i>position()</i> мы уже знакомы. Оператор <i>mod</i> дает нам остаток от деления на 2. А элемент <i>xsl:attribute</i> позволяет нам динамически подставлять в файл результатов различные атрибуты. Это очень мощный элемент, мы разберем еще одно применение этого элемента в следующем параграфе. А сейчас приведем для полноты картины таблицу результатов.
<table border="1">
  <tr bgcolor="#CCCCCC">
    <td align="center"><strong>Кличка</strong></td>
    <td align="center"><strong>Вес</strong></td>
    <td align="center"><strong>Цвет</strong></td>
  </tr>
  <tr bgcolor="#F5F5F5">

    <td>Шарик</td>
    <td align="right">18 кг</td>
    <td>рыжий с черными подпалинами</td>
  </tr>
  <tr bgcolor="#CCCCCC">
    <td>Тузик</td>
    <td align="right">10 кг</td>

    <td>белый с черными пятнами</td>
  </tr>
  <tr bgcolor="#F5F5F5">
    <td>Бобик</td>
    <td align="right">2 кг</td>
    <td>бело-серый</td>
  </tr>

  <tr bgcolor="#CCCCCC">
    <td>Трезор</td>
    <td align="right">25 кг</td>
    <td>черный</td>
  </tr>
</table><br>
<h3>Динамическое формирование атрибутов на примере параметров ссылки в теге &LT;a&GT;</h3>
<p>Предположим теперь, что в каждой строке таблицы нам нужно сделать ссылку на некоторую страницу и передать на эту страницу два параметра - кличку и вес собаки. Понятно, что для каждой строки эти параметры - свои, и их нельзя прописать явно в XSL-файл. Тем не менее задача легко решается при помощи элемента <i>xsl:attribute</i>.
<p>Мы не будем здесь строить специальный пример, ограничимся только соответствующим фрагментом XSL-файла.
<table><tr><td bgcolor=aqua><xmp>
<td>
<!-- Create reference to display details. Parameters - Dog Name and Dog Weight -->
<a target="_blank">
<xsl:attribute name="href">DisplayDetails.html?dogName=<xsl:value-of select="dogName"/>&amp;dogWeight=<xsl:value-of select="dogWeight"/></xsl:attribute>
<xsl:attribute name="title">To view some more details about <xsl:value-of select="dogName"/> click to dog name</xsl:attribute>
<xsl:value-of select="dogName"/>
</a>
</td>
</xmp></td></tr></table><br>
В этом примере в ячейке таблицы мы размещаем ссылку на страницу с подробными описаниями. Ссылка указывается в атрибуте href тега &LT;aGT;. Поскольку  на страницу передаются два параметра, значения которых берутся из XML-файла, этот атрибут формируется динамически. Обратите также внимание - символ & (амперсанд), разделяющий передаваемые параметры, записывается в XSL-файле в виде &amp;. Во втором атрибуте нам нужна всплывающая подсказка (атрибут <i>title</i>), которая появляется при наведении курсора мыши на ссылку. Текст этой подсказки тоже меняется динамически. Наконец, статический атрибут <i>target</i> мы разместили непосредственно в теге &LT;a&GT;.
<p>И, наконец, мы ознакомились с комментариями в XSL-файлах. Это вторая строка приведенного фрагмента.
<table><tr><td bgcolor=aqua><xmp>
<!-- Create reference to display details. Parameters - Dog Name and Dog Weight -->
</xmp></td></tr></table><br>
На этом мы завершим рассмотрение возможностей чистого XSLT и перейдем к последнему параграфу в этом документе - к динамическому изменению содержимого Web-страницы при помощи возможностей JavaScript и XML/XSLT без каких-либо дополнительных обращений к базе данных.
</BODY>
</HTML>