#include "myReadkey.h"

struct termios termiosBuffer;
// Функция, которая задает режим работы консоли. Вырезка из методички:
// 
// Регистр c_lflag описывает, как будет вести себя терминал при обработке и передаче информации в ЭВМ. Примером таких действий являются:
// - определение режима работы (канонический или неканонический). Флаг называется ICANON;
// - будут ли сразу отображаться на экране терминала вводимые с клавиатуры символы. Флаг называется ECHO;
// - будут ли обрабатываться управляющие символы, например прерывание работы программы (CTRL+C) или приостановка работы программы (CTRL+Z). 
// Флаг называется ISIG.
// Если установлен флаг ICANON, то включается канонический режим работы терминала. Как уже было сказано выше, это позволяет использовать символы
// редактирования строки в процессе построчного ввода. Если флаг ICANON не установлен, то терминал находится в режиме прямого доступа (англ. raw
// mode). Вызовы read будут при этом получать данные непосредственно из очереди ввода. Другими словами, основной единицей ввода будет одиночный символ,
// а не логическая строка. Программа при этом может считывать данные по одному символу или блоками фиксированного размера.
// Если установлен флаг ISIG, то разрешается обработка клавиш прерывания (intr) и аварийного завершения (quit). Обычно это позволяет пользователю
// завершить выполнение программы. Если флаг ISIG не установлен, то проверка не выполняется, и символы intr и quit передаются программе без изменений.
// Если установлен флаг ECHO, то символы будут отображаться на экране по мере их набора. Сброс этого флага полезен для процедур проверки паролей и
// программ, которые используют клавиатуру для особых функций, например, для перемещения курсора или команд экранного редактора.
//
// В целом для чего нужна эта функция - чтобы переключить режим терминала на каноничный, чтобы можно было считывать нажатия клавиш пользователя,
// установить флаг ECHO, чтобы эти символы никуда не выводились, и установить флаг ISIG, чтобы можно было использовать сочетание Ctrl+C для
// завершения работы машины.
int rk_mytermregime(int regime, int vtime, int vmin, int echo, int sigint)
{
	struct termios ws;
	// Чтобы получить текущие настройки терминала используется вызов
	// tcgetattr, который в качестве параметров получает номер дескриптора файла и
	// адрес памяти, куда поместить структуру (struct termios ws), описывающую режимы работы терминала.
	tcgetattr(0, &ws);
	// Установить каноничный режим работы терминала
	if(regime)
		ws.c_lflag |= ICANON;
	else
	{
		ws.c_lflag &= ~ICANON;
		// Вырезка из методички:
		//
		// Есть два элемента, описывающие поведение драйвера терминала при получении запроса на чтение данных в неканоническом режиме. 
		// А именно: какое количество символов должно быть в очереди, чтобы вызов read завершился (элемент, обозначаемый VMIN), и сколько
		// времени (в десятых долях секунды) ждать появления хотя бы одного символа в очереди (параметр VTIME). 
		// Значения этих элементов определяются только для неканонического режима. В каноническом режиме они равны соответственно
		// размеру буфера для строки и 0 (т.е. ожидать бесконечно долго). 
		//
		// За все время работы программы, в эту функцию всегда будет передаваться VMIN, равное единице, и VTIME, равное нулю.
		// Это значит, что функция (read) будет считывать по одному символу (из за VMIN) от пользователя (вместо целой строки) 
		// и сразу обратаывать его. VTIME всегда равно нулю.
		ws.c_cc[VMIN] = vmin;
		ws.c_cc[VTIME] = vtime;
	}
	// Установить флаг ECHO, чтобы символы, вводимые пользователем, не подавали на вывод в консоль
	if (!echo)
		ws.c_lflag &= ~ECHO;
	else
		ws.c_lflag |= ECHO;
	// Установить флаг ISIG
	if (!sigint)
		ws.c_lflag &= ~ISIG;
	else
		ws.c_lflag |= ISIG;
	// Для установки новых параметров драйвера терминала используется вызов tcsetattr, который в качестве параметров принимает номер дескриптора, 
	// новые значения флагов и правила их замены. Правила могут быть следующими:
	// 		TCSANOW. Немедленное выполнение изменений, что может вызвать проблемы, если в момент изменения флагов драйвер терминала
	// выполняет вывод на терминал.
	//		TCSADRAIN. Выполняет ту же функцию, что и TCSANOW, но перед установкой новых параметров ждѐт опустошения очереди вывода.
	//		TCSAFLUSH. Аналогично TCSADRAIN ждѐт, пока очередь вывода не опустеет, а затем также очищает и очередь ввода перед установкой
	// для параметров дисциплины линии связи значений, заданных в структуре tnew.
	tcsetattr(0, TCSANOW, &ws);
}
// Поскольку для считывания одиночных нажатий пользователя требуется менять состояние настроек терминала, возникла необходимость сохранять и 
// восстанавливать эти настройки после того, как будет считана очередная клавиша.
// Данная функция восстанавливает настройки терминала (которые хранятся в буфере termiosBuffer), которые были сохранены функцией (rk_mytermsave)
// (она чуть ниже реализована)
int rk_mytermrestore(void)
{
	tcsetattr(0, TCSANOW, &termiosBuffer);
}
// Сохранить настройки терминала в структуру (termiosBuffer)
int rk_mytermsave(void)
{
	tcgetattr(0, &termiosBuffer);
}
// Считать клавишу, нажатую пользователем
int rk_readkey(enum keys *key)
{
	char temp[10];
	// Сохранить текущие настройки консоли
	rk_mytermsave();
	// Сменить режим, в котором функция (read) считывает не строку, введенную пользователем, а очередную клавишу, и сразу обрабатывает ее.
	rk_mytermregime(0, 0, 1, 0, 1);
	// Считать клавишу в буфер temp
	read(0, temp, 10);
	// Если клавиша вроде стрелочек или F1...F12 (у таких клавиш в буфере temp первый символ = '\E')
	if (temp[0] == '\E')
	{
		// Если в temp[2] находится код 49, значит это клавиша F1...F12, и нужно взять код из 3 ячейки буфера, иначе это стрелочки
		if ((int)temp[2] == 49)
			*key = (int)temp[3];
		else
			*key = (int)temp[2];
	}
	else
		// Если клавиша - буква
		*key = (int)temp[0];
	// Восстановить настройки терминала
	rk_mytermrestore();
}
