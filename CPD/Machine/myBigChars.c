#include "myBigChars.h"
// В терминале используются так называемые "большие символы". Это цифры (0-9), буквы (A-F) и плюс (+). Большие символы
// используются для вывода текущей выбранной команды в левый нижний угол.
// Для рисования больших символов используется следующий алгоритм:
// Необходимо визуально начертить таблицу размерностью 8х8, необходимые области заполнить единицами, остальные области - нулями.
// Для единицы получится следующее:
//
// 00001000	(1)
// 00011000	(2)
// 00001000	(3)
// 00001000	(4)
// 00001000	(5)
// 00001000	(6)
// 00001000	(7)
// 00111110	(8)
//
// Для того, чтобы закодировать эту информацию, используется следующий метод: цифры ставятся в последовательности (4) (3) (2) (1) и получается
// число 00001000000010000001100000001000(2) -> 0x8081808(16), затем проделывается то же самое и для второй части большого символа. 
// Формируется последовательность (8) (7) (6) (5) в число 111110000010000000100000001000(2) -> 0x3E080808(16). Разбитие на два числа необходимо,
// т.к. в одно цисло типа int не поместится столько разрядов. То же самое проделывается и для остальных символов. Таким образом формируется
// двумерный массив (bigChars).

int bigChars[19][2] =
{
	{ 0x8081808 ,	0x3E080808 },	// 1
	{ 0x7E02027E, 	0x7E404040 },	// 2
	{ 0x7E02027E, 	0x7E020202 },	// 3
	{ 0x7E424242, 	0x2020202 },	// 4
	{ 0x7E40407E, 	0x7E020202 },	// 5
	{ 0x7E40407E, 	0x7E424242 },	// 6
	{ 0x202027E, 	0x2020202 },	// 7
	{ 0x7E42427E, 	0x7E424242 },	// 8
	{ 0x7E42427E, 	0x7E020202 },	// 9
	{ 0x4242427E, 	0x7E424242 },	// 0
	{ 0x7E422418,	0x42424242 },	// A
	{ 0x7C44427C,	0x7C424244 },	// B
	{ 0x4040407E,	0x7E404040 },	// C
	{ 0x4242427C,	0x7C424242 },	// D
	{ 0x7E40407E,	0x7E404040 },	// E
	{ 0x7E40407E,	0x40404040 },	// F
	{ 0x7E181800,	0x18187E },		// +
	{ 0x7E000000,	0x7E },			// -
	{ 0,			0}				// Пустой символ	
};
// Выводит строку символов с использованием дополнительной кодировочной таблицы
int bc_printA(char *str)
{
	// Ввести последовательность, которая позволит использовать дополнительную кодировочную таблицу в консоли, где есть псевдографика,
	// необходимая для отрисовки "больших символов". В этом режиме используются следующие символы: `afgijklmnopqrstuvwxyz{|}~. В отличии от 
	// обычного режима, эти символы отрисовываются иначе. Например "а"(ACS_CKBOARD) отрисовывается как закрашенный квадрат.
	write(1, "\E(0", strlen("\E(0"));
	// Вывести нужную строку
	write(1, str, strlen(str));
	// Ввести последовательность, которая выйдет из режима, где доступна дополнительная кодировочная таблица
	write(1, "\E(B", strlen("\E(B"));
	return 0;
}
// Выводит на экран «большой символ» размером восемь строк на восемь столбцов, левый верхний угол которого располагается в строке x и столбце y. 
// Третий и четвѐртый параметры определяют цвет и фон выводимых символов. «Символ» выводится, исходя из значений массива целых чисел,
// следующим образом. В первой строке выводится 8 младших бит первого числа, во второй – следующие 8, в третьей и 4-ой – следующие.
// В 5ой строке выводятся 8 младших бит второго числа и т.д. При этом если значение бита равно 0, то выводится символ
// «пробел», иначе – символ, закрашивающий знакоместо(ACS_CKBOARD)
// В качестве number передается (bigChars) с нужным адресом
int bc_printbigchar(int *number, int x, int y, enum colors color1, enum colors color2)
{
	// Символ чертится справа налево, поэтому сразу переводим координату на +7 по горизонтали
	x += 7;			
	// Назначит color2 как цвет фона текста
	mt_setbgcolor(color2);
	// Назначить color1 как цвет текста
	mt_setfgcolor(color1);
	// Цикл, который дважды пройдется по (bigChars) - по двум половинам символа
	for (int j = 0; j < 2; j++)
	{
		// Цикл, проходящий по всем 32 разрядам (bigChars)
		for (int i = 0; i < 32; i++)
		{
			// Перейти на x строку и y столбец
			mt_gotoXY(x, y);
			// Написать на псевдографике символ "a" (ACS_CKBOARD), если в нужной нам области находится единица в (bigChars), иначе - пробел
			bc_printA((((number[j] >> i) & 1) == 1 ? "a" : " "));
			// Отрисовываем справа - налево
			x--;
			// Если нарисовали очередные 8 "пикселей" - спускаемся вниз и сдвигаемся направо. Символ вырисовывается сверху - внизу, справа - налево.
			if (((i + 1) % 8) == 0)
			{
				x += 8;
				y++;
			}
		}
	}
	// Возвращаем цвет фона текста на консольный
	mt_setbgcolor(CONSOLE);
	// Возвращаем цвет текста на белый
	mt_setfgcolor(WHITE);
	return 0;
}
// Выводит на экран псевдографическую рамку, в которой левый верхний угол располагается в строке x1 и столбце y1, а еѐ ширина и высота равны
// y2 столбцов и x2 строк
int bc_box(int x1, int y1, int x2, int y2) 
{
	// Войти в режим дополнительной кодировочной таблицы
	write(1, "\E(0", strlen("\E(0"));
	// Перейти в координату (х1, у1), левый верхний угол
	mt_gotoXY(x1, y1);
	// Нарисовать верхний левый угол. 'l' в дополнительной кодировочной таблице выглядит как угол.
	write(1, "l", strlen("l"));
	// Перейти в правый верхний угол
	mt_gotoXY(x1 + x2 + 1, y1);
	// Нарисовать верхний правый угол
	write(1, "k", strlen("k"));
	// Перейти в нижний левый угол
	mt_gotoXY(x1, y1 + y2 + 1);
	// Нарисовать нижний левый угол
	write(1, "m", strlen("m"));
	// Перейти в правый нижний угол.
	mt_gotoXY(x1 + x2 + 1, y1 + y2 + 1);
	// Нарисовать правый нижний угол
	write(1, "j", strlen("j"));
	// Циклом нарисовать верхние и нижние горизонтальные линии 
	for (int i = 1; i < x2 + 1; i++)
	{
		// Переходить по верхним линиям
		mt_gotoXY(x1 + i, y1);
		// Нарисовать линии
		write(1, "q", strlen("q"));
		// Переходить по нижним линиям
		mt_gotoXY(x1 + i, y1 + y2 + 1);
		// Нарисовать линии
		write(1, "q", strlen("q"));
	}
	// Циклом нарисовать вертикальные линии слева и справа
	for (int i = 1; i < y2 + 1; i++)
	{
		// Переход по левым линиям
		mt_gotoXY(x1, y1 + i);
		// Нарисовать вертикальную линию
		write(1, "x", strlen("x"));
		// Переход по правым линиям
		mt_gotoXY(x1 + x2 + 1, y1 + i);
		// Нарисовать вертикальную линию
		write(1, "x", strlen("x"));
	}
	// Выйти из режима дополнительной кодировочной таблицы
	write(1, "\E(B", strlen("\E(B"));
	return 0;
}
// Эти функции реализованы в лабораторных, но в курсовой они не нужны. Можно их убрать
/*
int bc_getbigcharpos(int *big, int x, int y, int *value)
{
	if (x < 0 || x > 7 || y < 0 || y > 7)
		return -1;
	if (y < 4)
	{
		*value = (big[0] >> (y * 8 + 7 - x)) & 0x1;
	}
	else
	{
		*value = (big[2] >> ((y - 4) * 8 + 7 - x)) & 0x1;
	}
	return 0;
}

int bc_setbigcharpos(int *big, int x, int y, int value)
{
	if (x < 0 || x > 7 || y < 0 || y > 7)
		return -1;
	if (value < 0 || value > 1)
		return -1;
	if (y < 4)
	{
		if(value)
			big[0] |= (1 << (y * 8 + 7 - x));
		else
			big[0] &= ~(1 << (y * 8 + 7 - x));
	}
	else
	{
		if(value)
			big[2] |= (1 << ((y - 4) * 8 + 7 - x));
		else
			big[2] &= ~(1 << ((y - 4) * 8 + 7 - x));
	}
	return 0;
}

int bc_bigcharwrite(int fd, int *big, int count)
{
	char writen[20];
	int j = 0, k = 0;
	for (int i = 0; i < count; i++)
	{
		sprintf(writen, "%d-%d\n", big[0], big[1]);
		write(fd, writen, strlen(writen));
	}
}


int bc_bigcharread(int fd, int *big, int need_count, int *count)
{
	char writen[20], writen1[20], writenN[1];
	*count = 0;
	int j = 0, k = 0;
	sprintf(writen1, "%d-%d", big[0], big[1]);
	for (int i = 0; i < need_count; i++)
	{
		read(fd, writen, 20);
		read(fd, writenN, 1);
		if (!strcmp(writen, writen1))
			*count += 1;
		writen[0] = '\0';
	}
}
*/