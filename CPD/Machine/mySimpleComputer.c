#include "mySimpleComputer.h"
// Инициализация памяти машины SimpleComputer (всего 100 ячеек)
int sc_memoryInit()
{	
	// Цикл, инициализирующий 100 ячеек памяти нулями
	for (int i = 0; i < 100; i++)
		memory[i] = 0;
	return 0;
}
// Назначить новое значение для ячейки памяти. 
// В качестве первого аргумента - номер ячейки (от 0 до 99), 
// в качестве второго аргумента - новое значение
int sc_memorySet(int address, int value)
{
	// Если введен недопустимый номер ячейки
	if (address < 0 || address > 99)
	{
		// Перевести регистр "Выход за пределы памяти" в значение 1
		sc_regSet(REG_MEMOUTSIDE, 1);
		// Вызов внешней функции, которая графически изменит значение регистра
		updateFlag(REG_MEMOUTSIDE);
		// Вернуть -1 (функция завершена с ошибкой)
		return -1;
	}
	// Если новое значение (которое по условию задания является 15 разрядным двоичным числом)
	// выходит за рамки 15 разрядов (0x7FFF(16) -> 111 1111 1111 1111(2)), то завершаем функцию с ошибкой.
	if (value > 0x7FFF)
	{
		// Перевести регистр "Переполнение" в значение 1
		sc_regSet(REG_OVERFLOW, 1);
		// Вызов внешней функции, которая графически изменит значение регистра
		updateFlag(REG_OVERFLOW);
		// Вернуть -1 (функция завершена с ошибкой)
		return -1;
	}
	// Назначить значение (value) в ячейку по адресу (address)
	memory[address] = value;
	// Графически обновить содержимое ячейки по адресу address
	updateMemory(address);
	// Функция завершена успешно
	return 0;
}
// Получить значение ячейки по адресу (address) в переменную по адресу (value)
int sc_memoryGet(int address, int *value)
{
	// Если введен некорректный адрес, завершаем функцию с ошибкой, 
	// переведя регистр "Выход за пределы памяти" в активное состояние
	if (address < 0 || address > 99)
	{
		// Перевести регистр "Выход за пределы памяти" в активное состояние"
		sc_regSet(REG_MEMOUTSIDE, 1);
		// Вернуть -1 (функция завершена с ошибкой)
		return -1;
	}
	// В переменную по адресу (value) заносим значение ячейки по адресу (address)
	*value = memory[address];
	// Функция завершена успешно
	return 0;
}
// Сохранить содержимое памяти в бинарный файл
int sc_memorySave(char *filename)
{
	//int file = open(filename, O_WRONLY | O_EXCL | O_CREAT, S_IRWXU | S_IRWXO);
	// Открыть файл с названием (filename) для записи (0664 - флаг доступа, который содержит в себе требования к 
	// записи файла с нуля, бинарная запись)
	int file = creat(filename, 0664);
	// Записать в файл по дескриптору (file) содержимое массива (memory), записать 100 записей этого массива, где каждая ячейка 
	// имеет размер (short int)
	write(file, memory, 100 * sizeof(short int));
	// Закрыть дескриптор по адресу (file). Просто закрыть файл
	close(file);
	// Функция завершена успешно
	return 0;
}
// Загрузить содержимое файла под названием (filename) в массив (memory)
int sc_memoryLoad(char *filename)
{
	// Открыть файл с правами доступа (O_RDONLY) - только чтение.
	int file = open(filename, O_RDONLY);
	// Если дескриптор равен -1, то не смогли открыть файл (не найден, нет доступа), завершаем функцию с ошибкой
	if (file == -1)
		return -1;
	// Считываем содержимое в массив (memory). С файла считывается 100 значений, где каждая область имеет размер (short int).
	read(file, memory, 100 * sizeof(short int));
	// Закрыть дескриптор по адресу (file). Просто закрыть файл
	close(file);
	// Функция завершена успешно
	return 0;
}
// Вывести содержимое памяти. В курсовой не используется, было необходимо в лабораторных работах.
void sc_memoryPrint(void)
{
	int value;
	for (int i = 0; i < 100; i++)
	{
		sc_memoryGet(i, &value);
		printf("%d\t%s", value, ((i + 1) % 10 == 0) ? "\n" : "");
	}
}
// Инициализация регистров
int sc_regInit(void)
{
	// Всего есть 5 регистров 
	// (выход за пределы памяти, неизвестная команда, ошибка деления на ноль, переполнение, игнорирование тактовых импульсов).
	// Каждый регистр либо активен, либо нет.
	// Для хранения состояния отдельного регистра используется одна переменная (regs).
	// Активность отдельного регистра определяется наличием единичного бита в двоичной записи этой переменной.
	// То есть, имеется запись (regs) следующего вида - 00000ХХХХХ(2 система счисления).
	// Последние иксы определяют активность того или иного регистра.
	// Например, если самый крайний правый регистр содержит единицу, это значит, что регистр REG_MEMOUTSIDE (выход за пределы памяти) - активен.
	// mySimpleComputer.h содержит порядковый номер каждого регистра:
	// 		#define REG_MEMOUTSIDE		0x0		
	// 		#define REG_UNKNOWNCOMMAND	0x1		
	// 		#define REG_DIVIDEZERO		0x2		
	// 		#define REG_OVERFLOW		0x3		
	// 		#define REG_CLOCKIGNORE		0x4		
	// Эти номера значат, что самый крайний правый бит в (regs) отвечает за регистр выхода за пределы памяти, 
	// за ним следует регистр неизвестной команды и т.д.

	// Все регистры изначально - неактивны. Инициализируем нулем
	regs = 0;
	// Функция завершена успешно.
	return 0;
}
// Перевести регистр (reg) в состояние (value)
int sc_regSet(int reg, int value)
{
	// Если передан неверный регистр или неверное значение, то завершаем функцию с ошибкой
	if (reg < 0 || reg > REG_MAX || value < 0 || value > 0x1)
	{
		return -1;
	}
	// Если новое значение регистра (reg) единица, то "создаем" новое число, где единица побитово сдвинута на (reg) шагов влево,
	// и побитово складываем это число с (regs).
	// То есть, имеется изначально такое содержимое (regs): 00...00000. Мы хотим назначить регистр REG_DIVIDEZERO - активным.
	// Для этого создаем число 00...00100 (где единица сдвинута на две позиции влево в соответствием со значением REG_DIVIDEZERO).
	// И затем побитово складываем (regs) и это число, получается 00...00100. Если захотим назначить активным регистром REG_CLOCKIGNORE,
	// то нужно новое число будет иметь вид 00...10000. Сложив с (regs) получится число 00...10100.
	if (value == 1) 
		regs |= (1 << reg);
	// Если новое содержимое регистра (reg) ноль, то "создаем" новое число, где на месте нужного регистра стоит ноль, а остальные разряды
	// этого числа - единицы. Затем с этим числом проводится побитовое "И" с переменной (regs). 
	// Чтобы "создать" такое число, нужно сначала сформировать, как выше, число для нужного регистра и затем его инвертировать. То есть, 
	// в случае регистра REG_CLOCKIGNORE создается число 00...10000, затем оно инвертируется в 11...01111. Затем оно побитово перемножается
	// с переменной (regs). Было 00...0010100, стало 00...00100
	else if (value == 0) regs &= (~(1 << reg));
	// Графически обновить регистр
	updateFlag(reg);
	// Функция завершена успешно
	return 0;
}
// Получить содержимое регистра (reg) в переменную по адресу (value)
int sc_regGet(int reg, int *value)
{
	// Если указан неверный регистр, то завершаем функцию с ошибкой
	if (reg < 0 || reg > REG_MAX)
	{
		return -1;
	}
	// Если нужный регистр активен, то содержимое переменной (value) будет равно единице. Чтобы выявить активность регистра Х нужно сделать следующее:
	// 1) 01Х00
	// 2) 0100Х
	// 3) 0000Х
	// То есть, нужно сдвинуть нужный регистр в крайнее правое положение, а затем побитово умножить на единицу, чтобы избавиться от содержимого
	// других регистров.
	*value = (regs >> reg) & 0x1;
	// Функция завершена успешно
	return 0;
}
// Закодировать команду. Каждая ячейка памяти имеет вид:
//
// 0 		| 0110011 | 1011001    <------
// + 		|  33(16) |  59(16)
// -----------------------------
// признак	|   код	  | операнд
// команды	| операции|
// 
// как видно, первые 7 бит - это операнд, затем следует 7 бит - операция, затем еще 1 бит - признак того, что в данной ячейке содержится команда
// На вход этой функции подается номер операции и операнд, которые являются 7 битными числами.
int sc_commandEncode(int command, int operand, int *value)
{
	// Если операция или операнд выходят за пределы 7 бит, то завершаем функцию с ошибкой.
	if (command < 0 || command > 0x7F || operand < 0 || operand > 0x7F)
	{
		return -1;
	}
	// В переменную по адресу (value) заносим первые 7 бит - операнд
	*value = operand;
	// Затем вносим операцию, предварительно сдвинув ее на 7 бит влево.
	*value |= command << 7;
	// Имеется операнд 000...0000000YYYYYYY. Необходимо к нему добавить операцию 	000...0000000XXXXXXX.
	// Для этого, сдвигаем операцию на 7 бит влево, получая							000...XXXXXXX0000000.
	// И затем побитово складываем операцию и операнд:
	// 000...0000000YYYYYYY |
	// 000...XXXXXXX0000000 =
	// 000...XXXXXXXYYYYYYY
	// Функция завершена успешно
	return 0;
}
// Декодировать команду. Обратная функция кодированию команды. В функцию передается значение (value) (к примеру 000...XXXXXXXYYYYYYY), 
// после чего в переменные по адресам (command) и (operand) заносятся 000...XXXXXXX и 000...YYYYYYY соответственно.
int sc_commandDecode(int value, int *command, int *operand)
{
	// Если число имеет более 15 разрядов, то завершаем функцию с ошибкой.
	if (value > 0x7FFF)
	{
		return -1;
	}
	value = abs(value);
	// Для получения операции достаточно сдвинуть число на 7 разрядов вправо
	*command = value >> 7;
	// Для получения операнда нужно побитово умножить с 7 разрядным числом 1111111(2) -> 0x7F(16)
	*operand = value & 0x7F;
	// Функция завершена успешно
	return 0;
}
