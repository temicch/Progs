#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// Коды ошибок
enum errors
{
	// Ошибка открытия входного файла
	ERROR_OPENING_INPUT_FILE,
	// Ошибка открытия выходного файла
	ERROR_OPENING_OUTPUT_FILE,
	// Другой тип ошибки (вроде ошибок в строке и т.п. - то есть все ошибки, не входящие в список выше)
	ERROR_OTHER,
	// Успешно
	SUCCESS
};

// Функция из модуля "Командной панели" для кодирования команды
// Каждая ячейка памяти имеет вид:
//
// 0 		| 0110011 | 1011001    <------
// + 		|  33(16) |  59(16)
// -----------------------------
// признак	|   код	  | операнд
// команды	| операции|
// 
// как видно, первые 7 бит - это операнд, затем следует 7 бит - операция, затем еще 1 бит - признак того, что в данной ячейке содержится команда
// На вход этой функции подается номер операции и операнд, которые являются 7 битными числами.
int sc_commandEncode(int command, int operand, int *value)
{
	// Если операция или операнд выходят за пределы 7 бит, то завершаем функцию с ошибкой.
	if (command < 0 || command > 0x7F || operand < 0 || operand > 0x7F)
	{
		return -1;
	}
	// В переменную по адресу (value) заносим первые 7 бит - операнд
	*value = operand;
	// Затем вносим операцию, предварительно сдвинув ее на 7 бит влево.
	*value |= command << 7;
	// Имеется операнд 000...0000000YYYYYYY. Необходимо к нему добавить операцию 	000...0000000XXXXXXX.
	// Для этого, сдвигаем операцию на 7 бит влево, получая							000...XXXXXXX0000000.
	// И затем побитово складываем операцию и операнд:
	// 000...0000000YYYYYYY |
	// 000...XXXXXXX0000000 =
	// 000...XXXXXXXYYYYYYY
	// Функция завершена успешно
	return 0;
}
// Основная функция транслятора
// Функция возвращает значения из перечисления (errors), описанного выше
int ASM(char *name1, char *name2)
{
	int i,
		nm,
		value,
		command,
		operand,
		flag = 1,
		file2;
	// Массив для хранения ячеек памяти с командами
	short int memory[100];
		
	char buf1[20],c;
	FILE *file1;
	// Открываем входной файл под названием (name1)
	file1 = fopen(name1, "rt");
	// Если (file1) вернул NULL, значит не удалось открыть файл (указано неверное название или нет доступа к файлу), завершаем программу с ошибкой
	if (file1 == NULL)	
	{
		return ERROR_OPENING_INPUT_FILE;
	}
	// Открытие(!) файла под названием (name2) с режимом 0664, который представляет собой создание (перезапись) файла с двоичной 
	// записью информации в него
	file2 = creat(name2, 0664);	
	// Если (file2) вернул -1, значит не удалось открыть файл (нет доступа к файлу), завершаем программу с ошибкой
	if (file2 == -1)
	{
		return ERROR_OPENING_OUTPUT_FILE;
	}
	// Инициализация ячеек памяти нулями
	for (i=0; i < 100; i++)
		memory[i]=0;
	// Цикл для чтения входного файла. Входной файл имеет следующую структуру:
	//
	// 00 READ 09 ; (Ввод А)
	// 01 READ 10 ; (Ввод В)
	// 02 LOAD 09 ; (Загрузка А в аккумулятор)
	// 03 SUB 10 ; (Отнять В)
	// 04 JNEG 07 ; (Переход на 07, если отрицательное)
	// 05 WRITE 09 ; (Вывод А)
	// 06 HALT 00 ; (Останов)
	// 07 WRITE 10 ; (Вывод В)
	// 08 HALT 00 ; (Останов)
	// 09 =	+0000 ; (Переменная А)
	// 10 = +9999 ; (Переменная В)
	//
	// Где первое число - номер ячейки, где записана команда. Затем следует название команды. После - операнд.
	do
	{
		// Считывание ячейки памяти в переменную (nm)
		fscanf(file1,"%d",&nm);
		// Перевести каретку памяти на один символ вправо (то есть пропустить пробел между номером ячейки памяти и командой)
		fseek(file1,sizeof(char),1);	
		// Очистить буфер, куда считывается название команды
		buf1[0]='\0';
		// Считать команду в переменную (buf1)
		fscanf(file1,"%s",buf1);	
		// Если встречено "равно", значит встречена конструкция вида:
		//
		// 10 = +9999 ; (Переменная В)
		//
		// В таком случае, необходимо считать сдвинуться на символ вправо (пропустить пробел) и считать число в переменную (value)
		if (!strcmp(buf1, "="))
		{
			// Пропустить пробел
			fseek(file1,sizeof(char),1);
			// Считать число в переменную (value)
			fscanf(file1,"%d",&value);
		}
		// Если встречена команда, отличная от "равно"
		else
		{ 
			// В соответствие к командам из методички, ставятся необходимые номера команд:
			//
			// READ 	10 		Ввод с терминала в указанную ячейку памяти с контролем переполнения
			// WRITE 	11 		Вывод на терминал значения указанной ячейки памяти
			// ....
			// HALT 	43 		Останов, выполняется при завершении работы программы
			//
			// Если встречена строка READ, то в качестве команды указывается номер 10 (в шестнадцатеричной системе счисления) в соответствии
			// с таблицей из методички. Тоже самое делается и для дальнейших команд
			if (!strcmp(buf1,"READ"))
				command = 0x10;
			else
			if (!strcmp(buf1,"WRITE"))
				command = 0x11;
			else
			if (!strcmp(buf1,"LOAD"))
				command = 0x20;
			else
			if (!strcmp(buf1,"STORE"))
				command = 0x21;
			else
			if (!strcmp(buf1,"ADD"))
				command = 0x30;
			else
			if (!strcmp(buf1,"SUB"))
				command = 0x31;
			else
			if (!strcmp(buf1,"DIVIDE")) 
				command = 0x32;
			else
			if (!strcmp(buf1,"MUL"))
				command = 0x33;
			else
			if (!strcmp(buf1,"JUMP"))
				command = 0x40;
			else
			if (!strcmp(buf1,"JNEG"))
				command = 0x41;
			else
			if (!strcmp(buf1,"JZ"))
				command = 0x42;
			else
			if (!strcmp(buf1,"HALT"))
				command = 0x43;
			else
			// Пользовательская функция NOT
			if (!strcmp(buf1,"JP"))
				command = 0x58;
			// Если встречена команда, не указанная выше, завершаем программу, при это написав, какую команду не нашли
			else 
			{
				printf("Неизвестная команда в ячейке памяти №%d\n",nm);
				return ERROR_OTHER;
			}	
			// Пропустить пробел
			fseek(file1,sizeof(char),1);
			// Считать операнд
			fscanf(file1,"%d",&operand);
			// Закодировать команду в переменную (value)
			sc_commandEncode(command, operand, &value);
		}	
		// В ячейку памяти по адресу (nm) присвоить закодированную команду (или значение переменной, в зависимости от того, какая команда была)
		memory[nm] = value;	
		// Считывать символы, пока не будет встречена цифра (начало очередной ячейки) или конец файла. Если встречен конец файла - 
		// присваиваем пременной (flag) значение 0, что ведет к окончанию внешнего цикла.
		do
		{
			if(fscanf(file1,"%c",&c) == EOF)
			flag=0;
		}
		while(c!='\n');
	}
	while (flag);
	// Записать в файл, дескриптор которого находится в переменной (file2), ячейки памяти из массива (memory). Запишется 100 ячеек размером
	// sizeof(short int) каждая
	write(file2, memory, 100 * sizeof(short int));
	// Закрыть файлы
	fclose(file1);
	close(file2);
	return SUCCESS;
}

int main(int argc, char **argv)
{
	// Если количество аргументов не равно 3, то есть не введены входной/выходной файл (первым аргументом всегда является название функции),
	// то выводим справку
	if (argc != 3) 
	{ 
		printf("\nТранслятор Simple ASSEMBLER to Binary file\n  использование: ./ASM INPUT_FILE.sa OUTPUT_FILE.o\n"); 
		return 0;
	}
	// Запускаем главную функцию трансляции, в которую передаем название входного файла (argv[1]) и название выходного файла (argv[2]).
	// Функция возвращает код ошибки, в случае если при трансляции что то пошло не так.
	int err = ASM(argv[1], argv[2]);
	switch (err)
	{
		case SUCCESS: 					printf("Файл транслирован успешно\n"); break;
		case ERROR_OPENING_INPUT_FILE: 	printf("Ошибка при открытии исходного файла\n"); break;
		case ERROR_OPENING_OUTPUT_FILE: printf("Ошибка при открытии выходного файла\n"); break;
	}
	return 0;
}
